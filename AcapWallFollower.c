#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     eyes,           sensorEV3_IRSensor)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          head,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          right,         tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int GAP = 40;
//KD should be bigger than KP
int KP = 1;
int KD = 1;
int LS = 5;
int LM = 15;
int RS = 5;
int RM = 15;

void depan(int masa){
		setMotor(left, 10);
		setMotor(right, 10);
		wait1Msec(masa);
		stopAllMotors();
}

void PIDFollowWall(){
	while(true){
			int lastError = 0;
			int position = getIRDistance(eyes);
			int error = position - GAP;

			if(error < GAP){
				int speed = (KP * error) + (KD * (error - lastError));
				lastError = error;

				int rightSpeed = RS + speed;
				int leftSpeed = LS - speed;

				if (rightSpeed > RM) rightSpeed = RM;
				if (leftSpeed > LM) leftSpeed = LM;
				if (rightSpeed < 0) rightSpeed = 0;
				if (leftSpeed < 0) leftSpeed = 0;
				setMotor(left, leftSpeed);
				setMotor(right, rightSpeed);
			}
			else{
				stopAllMotors();
				break;
			}
	}
}

void followWall(bool flag){
		if(flag){
				clearTimer(T1);
				clearTimer(T2);
				flag = false;
		}

		int leftSpeed = 10;
		int rightSpeed = 10;

		//too far, at node
		if ((getIRDistance(eyes)-GAP) > GAP){
				//assign node
				stopAllMotors();
				depan(1000);
				resetGyro(gyro);
				setMotor(right, 3);
				waitUntil(getGyroDegrees(gyro) < -87);
				stopMotor(right);
				depan(1000);
		}
		//right drift
		else if((getIRDistance(eyes)-GAP) > 5){
				setMotor(right, rightSpeed + 1 + getTimer(T1, seconds));
				setMotor(left, leftSpeed - 1 - getTimer(T1, seconds));
		}
		//left drift
		else if((getIRDistance(eyes)-GAP) < -5){
				setMotor(left, leftSpeed + 1 + getTimer(T2, seconds));
				setMotor(right, rightSpeed - 1 - getTimer(T2, seconds));
		}
		//straight
		else{
				clearTimer(T1);
				clearTimer(T2);
				setMotor(left, leftSpeed);
				setMotor(right, rightSpeed);
		}
}

task main()
{
	PIDFollowWall();
}
