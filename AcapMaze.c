#pragma config(Sensor, S1,     eyes,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     garis,          sensorEV3_Color)
#pragma config(Sensor, S4,     gyro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          head,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static int choices = 0;
static int optimizedDecisions[20];
int Tp = 40;
int options = 0;
int turnDeg = 85;
bool dahNampak = false;
float lantai = 10;
int decisions[20];
//pusing -1 for left 1 for right

void depan(float masa){
	resetTimer(T1);
	while(getTimer(T1, seconds) < masa){
		setMotorSpeed(left, Tp);
		setMotorSpeed(right, Tp);
	}
	stopAllMotors();
	wait1Msec(250);
}

//pusing -1 for left 1 for right
void pusing(int where){

	resetGyro(gyro);
	wait1Msec(500);
	if(where != 0){
		while(abs(getGyroDegrees(gyro)) < turnDeg){
			//if(abs(getGyroDegrees(gyro)) < turnDeg){
				setMotorSpeed(left, -Tp/5 * where);
				setMotorSpeed(right, Tp/5 * where);
			//}
			//else if(abs(getGyroDegrees(gyro)) > turnDeg){
			//	setMotorSpeed(left, Tp/2 * where);
			//	setMotorSpeed(right, -Tp/2 * where);
			//}
		}

		setMotorSpeed(left, -5 * where);
		setMotorSpeed(right, 5 * where);
		wait1Msec(250);
	}
	stopAllMotors();

}

//to be changed

//void depanSampai(float gapUS, float gapIR){

//	depan(3);

//	while (getUSDistance(eyes)<=(2 * gapUS) && getIRDistance(eyesIR) > gapIR){
//		setMotorSpeed(left, Tp);
//		setMotorSpeed(right, Tp);
//	}
//	depan(1.5);
//	stopAllMotors();
//	wait1Msec(250);
//}

void depanSampai(float gapLeft, float gapFront, float lantai){
	float front, side;
	front = 0;
	side = 0;

	while(getColorReflected(garis) > lantai){
		//front = getIRDistance(eyesIR);
		front = getUSDistance(eyes);
		setMotorTarget(head, -90, 10);
		waitUntilMotorStop(head);
		wait1Msec(250);
		//side = getIRDistance(eyesIR);
		side = getUSDistance(eyes);
		setMotorTarget(head, 0, 10);
		waitUntilMotorStop(head);
		if (front < (gapFront * 1.05) || side > (gapLeft * 1.5)){
			stopAllMotors();
			wait1Msec(250);
			//if (getColorReflected(garis) < lantai)
			//	dahNampak = true;
			return;
		}
		else{
			depan(0.5);
		}
	}
	playSound(soundBeepBeep);
	dahNampak = true;
}

void tengok(float gapLeft){
	float scans[3];
	//for (int j = 0; j < 3; j++)
	//	options[j] = 0;
	//static int options[3] = {0, 0, 0};
	//options[0] left
	//options[1] forward
	//options[2] right
	options = 0;

	setMotorTarget(head, -90, 10);
	waitUntilMotorStop(head);
	//scans[0] = getIRDistance(eyesIR);
	scans[0] = getUSDistance(eyes);
	wait1Msec(250);

	setMotorTarget(head, 0, 10);
	waitUntilMotorStop(head);
	//scans[1] = getIRDistance(eyesIR);
	scans[1] = getUSDistance(eyes);
	wait1Msec(250);

	setMotorTarget(head, 90, 10);
	waitUntilMotorStop(head);
	//scans[2] = getIRDistance(eyesIR);
	scans[2] = getUSDistance(eyes);
	wait1Msec(250);

	setMotorTarget(head, 0, 10);
	waitUntilMotorStop(head);
	wait1Msec(250);

	float gap = 2 * gapLeft;
	//if (gap > 80){
	//	gap = 80;
	//}

	//for (int i = 0; i < 3; i++){
	//	if(scans[i] > gap){
	//		options[i] = 1;
	//	}
	//}
	if (scans[0] > gap)
		options = options + 1;
	if (scans[1] > gap)
		options = options + 2;
	if (scans[2] > gap)
		options = options + 4;
}

void decide(){
	if (options == 1 || options == 3 || options == 5 || options == 7){//left
		depan(2.5);
		pusing(-1);
		depan(2.5);
	}
	else if(options == 2 || options == 6)//forward
		pusing(0);
	else if(options == 4){//right
		pusing(1);
		depan(2.5);
	}
	else{//back
		pusing(-1);
		pusing(-1);
		depan(2.5);
	}
}

void compile(){
	decisions[choices] = options;
	choices++;
}

void simplify(){
	int before, current, after;
	int done = 0;
	for (int i = 0; i < choices; i++){
		if(i == 0){
			optimizedDecisions[done] = decisions[i];
			done++;
		}
		else{
			before = decisions[i-1];
			current = decisions[i];
			after = decisions[i+1];
			if(current == 0){

			}
		}
	}
}

task main(){

	//int * i;
	//int f[3];

	//float gapFront = getIRDistance(eyes);
	//float lantai = getColorReflected(garis) * 0.6;
	//setMotorTarget(head, -90, 10);
	//waitUntilMotorStop(head);
	////float gapLeft = getIRDistance(eyesIR);
	//float gapLeft = getUSDistance(eyes);
	//float gapFront = gapLeft;
	float gapLeft = 22.0;
	float gapFront = 20.0;
	//wait1Msec(250);
	//setMotorTarget(head, 0, 10);
	//waitUntilMotorStop(head);
	//wait1Msec(250);

	for (int i = 0; i < 20; i++){
		decisions[i] = 0;
		optimizedDecisions[i] = 0;
	}

	while(true){
		depanSampai(gapLeft, gapFront, lantai);
		if(dahNampak)
			break;
		tengok(gapLeft);
		decide();
	}

	wait1Msec(2000);
}
